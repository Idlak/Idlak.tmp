<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: The Idlak context extraction system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('idlakcex.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Idlak context extraction system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="idlakcex_intro"></a>
Introduction</h1>
<p>In order to train our speech synthesiser, we need to extract information about the context in which each phone exists. For example, desirable information might be the phones in proximity to it, its position within the segment or syllabic stress. The role of idlakcex is to take the idlaktxp output and perform this extraction.</p>
<p>It outputs a string for each phone, which consists of values separated by unique delimiters, indicating which context the subsequent value pertains to. These full context models are very similar to model names used in HTS/HTK but with some regularisation.</p>
<p>For example here is a full contect model name in HTS/HTK</p>
<pre class="fragment">ae^l-ax+s=w@2_2/A:1_1_1/B:0-0-3@2-1&amp;2-21
#1-12$1-3!1-1;1-7|ax/C:1+0+3/D:0_0
/E:content+2@1+15&amp;1+7#0+2/F:aux_1
/G:0_0/H:22=15^1=1|NONE/I:0=0/J:22+15-1
</pre><p>The delimiters shift on each field to allow a regular expression to uniquely extract a field. This follows the initial HTK style of naming triphones and quinphones for ASR. In the above we have phone contexts in the first 5 fields:</p>
<table class="doxtable">
<tr>
<th>context</th><th>left delimiter</th><th>value</th><th>right delimiter </th></tr>
<tr>
<th>left left phone context</th><th></th><th>ae</th><th>^ </th></tr>
<tr>
<th>left phone context</th><th>^</th><th>l</th><th>- </th></tr>
<tr>
<th>phone context</th><th>-</th><th>ax</th><th>+ </th></tr>
<tr>
<th>right phone context</th><th>+</th><th>s</th><th>= </th></tr>
<tr>
<th>right right phone context</th><th>=</th><th>w</th><th>@ </th></tr>
</table>
<p>Idlak continues to use the HTK style phone delimiters, but as standard replaces all other delimiters with the string /XX: where XX is a two digit field number. This makes the models a little longer but easier to intepret.</p>
<p>For example:</p>
<pre class="fragment">^pau~ae-l+ah=s/00:0/01:2/02:1/03:0/04:1/05:PAU
/06:NN/07:VBD/08:1/09:3/10:3/11:0/12:2/13:1
/14:15/17:LL
</pre><p>Field values can be integers or strings as in HTS/HTK.</p>
<p>These string names are an intermediate form in Kaldi. In the standard Kaldi system phone names are replaced by integer values. This is not possible with the full context models used in synthesis because the large number of contexts leads to trillions of different possible phone names. Thus internally in Kladi Idlak phone names are coded as a vector of integers. Each position on the vector refers to a context and each integer to a vlaue, either a direct integer value, or an index into a lookup table to represent a string value.</p>
<p>A key requirement for current parametric synthesis systems is to be able to query a phone name for a context value, and build a tree of models in order to automatically group the very sparse set of full context models to a less sparse set of leaf models.</p>
<p>The question set is a list where each question has the form given this context are any of these values present.</p>
<p>In HTK such questions are written as follows: </p><pre class="fragment">QS "LL-Stop" {^b~*,^d~*,^g~*,^k~*,^p~*,^t~*}
</pre><p> whereas in Kladi Idlak they would have the form </p><pre class="fragment">5 ? 7 9 15 20 27 31
</pre><p>The context index is the first value and matches our context fields in our phone name with an offset of 5. This is for compatibility reasons with Kaldi where, given a context width of 5 and a central position of 3 (i.e. &ndash;central-position=2 &ndash;context-width=5 in tree building options), the first five contexts are repeated quinphone contexts where questions may be generated automatically.</p>
<p>Unlike HTS where the questions are set in advance and not altered, in Kaldi Idlak they are generated from a superset, making it easier to alter, add, and remove contexts and context values while ensuring the questions remain synchonised with the with the context extraction.</p>
<p>In the next two sections we give more detail on how context extraction is configured, and how the question sets are generated.</p>
<h1><a class="anchor" id="idlakcex_archi"></a>
Context Architecture</h1>
<p>The system's primary mode of action is to run each of the context extraction functions. The developer writes the function bodies, adhering to a function naming convention to be explained later, whilst the header file and a macro for calling them all are automatically generated by a Python script.</p>
<p>The functions themselves must also be described in an XML file, including the following information:</p>
<ul>
<li><b>delim:</b> The delimiter to be used in the output string, ahead of this feature's value.</li>
<li><b>htsname:</b> The name by which the feature is referred to in HTS.</li>
<li><b>desc:</b> A short description of the feature's purpose.</li>
<li><b>name:</b> The name of the feature. This is used as part of the function name in the C++ file, so should conform to those standards.</li>
<li><b>min</b> (optional): The minimum acceptable value for this feature.</li>
<li><b>max</b> (optional): The maximum acceptable value for this feature.</li>
<li><b>set</b> (optional): If this feature is to have non-integer values, the set from which possible values should be drawn.</li>
<li><b>pauctx</b> (optional): Whether or not context should continue (as opposed to being blocked) when meeting two consecutive pauses.</li>
</ul>
<p>If the 'set' attribute is used, a set element must be defined, using the same name, which enumerates all possible values for the set.</p>
<p>Below is an example of such an XML file:</p>
<pre class="fragment">&lt;cex maxfieldlen="3" pausehandling="SPT"&gt;
  &lt;!-- Sets must be specified before feature functions that depend on them --&gt;
  &lt;set name="phone" null="X"&gt;
    &lt;item name="pau"/&gt;
    &lt;item name="aa"/&gt;
    &lt;item name="ae"/&gt;
    &lt;item name="ah"/&gt;
    &lt;item name="ao"/&gt;
    &lt;item name="aw"/&gt;
    &lt;item name="ax"/&gt;
    &lt;item name="ay"/&gt;
    &lt;item name="b"/&gt;
    &lt;item name="ch"/&gt;
    &lt;item name="d"/&gt;
    &lt;item name="dx"/&gt;
    &lt;item name="dh"/&gt;
    &lt;item name="eh"/&gt;
    &lt;item name="er"/&gt;
    &lt;item name="ey"/&gt;
    &lt;item name="f"/&gt;
    &lt;item name="g"/&gt;
    &lt;item name="hh"/&gt;
    &lt;item name="ih"/&gt;
    &lt;item name="iy"/&gt;
    &lt;item name="jh"/&gt;
    &lt;item name="k"/&gt;
    &lt;item name="l"/&gt;
    &lt;item name="m"/&gt;
    &lt;item name="n"/&gt;
    &lt;item name="ng"/&gt;
    &lt;item name="ow"/&gt;
    &lt;item name="oy"/&gt;
    &lt;item name="p"/&gt;
    &lt;item name="r"/&gt;
    &lt;item name="s"/&gt;
    &lt;item name="sh"/&gt;
    &lt;item name="t"/&gt;
    &lt;item name="th"/&gt;
    &lt;item name="uh"/&gt;
    &lt;item name="uw"/&gt;
    &lt;item name="v"/&gt;
    &lt;item name="w"/&gt;
    &lt;item name="y"/&gt;
    &lt;item name="z"/&gt;
    &lt;item name="zh"/&gt;
    &lt;item name="sil"/&gt;
    &lt;item name="X"/&gt;
  &lt;/set&gt;
  &lt;set name="pos" null="X"&gt;
    &lt;item name="CC"/&gt;
    &lt;item name="CD"/&gt;
    &lt;item name="DT"/&gt;
    &lt;item name="EX"/&gt;
    &lt;item name="FW"/&gt;
    &lt;item name="IN"/&gt;
    &lt;item name="IN/that"/&gt;
    &lt;item name="JJ"/&gt;
    &lt;item name="JJR"/&gt;
    &lt;item name="JJS"/&gt;
    &lt;item name="LS"/&gt;
    &lt;item name="MD"/&gt;
    &lt;item name="NN"/&gt;
    &lt;item name="NNS"/&gt;
    &lt;item name="NP"/&gt;
    &lt;item name="NPS"/&gt;
    &lt;item name="PDT"/&gt;
    &lt;item name="POS"/&gt;
    &lt;item name="PP"/&gt;
    &lt;item name="PP$"/&gt;
    &lt;item name="RB"/&gt;
    &lt;item name="RBR"/&gt;
    &lt;item name="RBS"/&gt;
    &lt;item name="RP"/&gt;
    &lt;item name="SENT"/&gt;
    &lt;item name="SYM"/&gt;
    &lt;item name="TO"/&gt;
    &lt;item name="UH"/&gt;
    &lt;item name="VB"/&gt;
    &lt;item name="VBD"/&gt;
    &lt;item name="VBG"/&gt;
    &lt;item name="VBN"/&gt;
    &lt;item name="VBP"/&gt;
    &lt;item name="VBZ"/&gt;
    &lt;item name="VD"/&gt;
    &lt;item name="VDD"/&gt;
    &lt;item name="VDG"/&gt;
    &lt;item name="VDN"/&gt;
    &lt;item name="VDP"/&gt;
    &lt;item name="VDZ"/&gt;
    &lt;item name="VHB"/&gt;
    &lt;item name="VHD"/&gt;
    &lt;item name="VHI"/&gt;
    &lt;item name="VHP"/&gt;
    &lt;item name="VHZ"/&gt;
    &lt;item name="VV"/&gt;
    &lt;item name="VVD"/&gt;
    &lt;item name="VVG"/&gt;
    &lt;item name="VVN"/&gt;
    &lt;item name="VVP"/&gt;
    &lt;item name="VVZ"/&gt;
    &lt;item name="WDT"/&gt;
    &lt;item name="WP"/&gt;
    &lt;item name="WP$"/&gt;
    &lt;item name="WRB"/&gt;
    &lt;item name=":"/&gt;
    &lt;item name="$"/&gt;
    &lt;item name="PAU"/&gt;
    &lt;item name="X"/&gt;
  &lt;/set&gt;
  &lt;set name="tone" null="X"&gt;
    &lt;item name="LH"/&gt;
    &lt;item name="LL"/&gt;
    &lt;item name="X"/&gt;
  &lt;/set&gt;
  &lt;feat delim="^" htsname="LL" desc="phone_before_before" name="BackwardBackwardPhone" set="phone" pauctx="false"&gt;
    &lt;mapping fromstr="X" tostr="sil"/&gt;
  &lt;/feat&gt;
  &lt;feat delim="~" htsname="L" desc="phone_before" name="BackwardPhone" set="phone" pauctx="false"&gt;
    &lt;mapping fromstr="X" tostr="sil"/&gt;
  &lt;/feat&gt;
  &lt;feat delim="-" htsname="C" desc="current_phone" name="Phone" set="phone" pauctx="false"&gt;
    &lt;mapping fromstr="X" tostr="sil"/&gt;
  &lt;/feat&gt;
  &lt;feat delim="+" htsname="R" desc="phone_forward" name="ForwardPhone" set="phone" pauctx="false"&gt;
    &lt;mapping fromstr="X" tostr="sil"/&gt;
  &lt;/feat&gt;
  &lt;feat delim="=" htsname="RR" desc="phone_forward_forward" name="ForwardForwardPhone" set="phone" pauctx="false"&gt;
    &lt;mapping fromstr="X" tostr="sil"/&gt;
  &lt;/feat&gt;
  &lt;feat delim="/00:" htsname="Seg_Fw" desc="segment_location_from_front" name="SegmentLocationFromFront" min="0" max="7" &gt;
  &lt;feat delim="/01:" htsname="Seg_Bw" desc="segment_location_from_back" name="SegmentLocationFromBack" min="0" max="7" /&gt;
  &lt;feat delim="/02:" htsname="L-Syl_Stress" desc="left_syllabic_stress" name="BackwardSyllableStress" min="0" max="1" pauctx="false" /&gt;
  &lt;feat delim="/03:" htsname="C-Syl_Stress" desc="current_syllabic_stress" name="SyllableStress" min="0" max="1" pauctx="false" /&gt;
  &lt;feat delim="/04:" htsname="R-Syl_Stress" desc="right_syllabic_stress" name="ForwardSyllableStress" min="0" max="1" pauctx="false" /&gt;
  &lt;feat delim="/05:" htsname="L-Word_GPOS" desc="left_part_of_speech" name="BackwardWordPosTag" set="pos" pauctx="false" /&gt;
  &lt;feat delim="/06:" htsname="C-Word_GPOS" desc="part_of_speech" name="WordPosTag" set="pos" pauctx="false" /&gt;
  &lt;feat delim="/07:" htsname="R-Word_GPOS" desc="right_part_of_speech" name="ForwardWordPosTag" set="pos" pauctx="false" /&gt;
  &lt;feat delim="/08:" htsname="L-Syl_Num-Segs" desc="left_syllable_no_segments" name="BackwardSyllableNumPhones" min="0" max="7"/&gt;
  &lt;feat delim="/09:" htsname="C-Syl_Num-Segs" desc="current_syllable_no_segments" name="SyllableNumPhones" min="0" max="7"/&gt;
  &lt;feat delim="/10:" htsname="R-Syl_Num-Segs" desc="right_syllable_no_segments" name="ForwardSyllableNumPhones" min="0" max="7"/&gt;
  &lt;feat delim="/11:" htsname="L-Word_Num-Syls" desc="-" name="BackwardWordNumSyls" min="0" max="7"/&gt;
  &lt;feat delim="/12:" htsname="C-Word_Num-Syls" desc="-" name="WordNumSyls" min="0" max="7"/&gt;
  &lt;feat delim="/13:" htsname="R-Word_Num-Syls" desc="-" name="ForwardWordNumSyls" min="0" max="7"/&gt;
  &lt;feat delim="/14:" htsname="C-Phrase_Num-Words" desc="-" name="PhraseNumWords" min="0" max="30"/&gt;
  &lt;feat delim="/17:" htsname="C-Phrase_TOBI_End-tone" desc="-" name="PhraseTobiEndTone" set="tone"/&gt;
&lt;/cex&gt;
</pre><p>Function names in the C++ should contain the following components in the following order:</p>
<ul>
<li><b>CexFunc</b> </li>
<li><b>String</b> or <b>Int:</b> depending on the feature's value type.</li>
<li>The contents of the 'name' field in the XML file.</li>
</ul>
<p>For example, given the previously-mentioned XML file, the following would be legitimate function names; <em>CexFuncStringBackwardBackwardPhone</em>, <em>CexFuncIntWordNumSyls</em>, <em>CexFuncStringPhraseTobiEndTone</em>.</p>
<h1><a class="anchor" id="idlaxcex_extraction"></a>
Context Extraction</h1>
<p>idlakcex takes output from the front end processor idlaktxp as input, queries the XMl structures within the input and adds the full context model names. It also adds a header to the XMl which describes the context extraction functions used. This helps track errors and is also used to encode full context models into kaldi style integer vectors.</p>
<p>An example of running the idlakcex on input generated by the idlak test system is shown below.</p>
<pre class="fragment">cd src/idlaktxp
make test
cd ../idlaktxpbin
./idlakcex --pretty --cex-arch=hts --tpdb=../../idlak-data/en/ga ../idlaktxp/test_data/mod-syllabify-out002.xml -
</pre><p>The switch &ndash;pretty adds whitespace to the XMl to make it human readable, &ndash;cex-arch argument can be used to switch between different setups. In this example it is set to hts which produces context models names with the delimeters described above, which matches the hts style question file (see <a class="el" href="idlakcex.html#idlakcex_qarchi">Question Architecture</a>). This output was used together with this question file to test the front end against festival using HTS (see <a class="el" href="idlakhtstest.html">Testing the Idlak Front End with HTS</a>).</p>
<p>the first few lines of the output are as follows: </p><pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;parent&gt;
	&lt;txpheader&gt;
		&lt;cex&gt;
			&lt;cexfunction name="BackwardBackwardPhone" delim="^" isinteger="0" /&gt;
			&lt;cexfunction name="BackwardPhone" delim="~" isinteger="0" /&gt;
			&lt;cexfunction name="Phone" delim="-" isinteger="0" /&gt;
			&lt;cexfunction name="ForwardPhone" delim="+" isinteger="0" /&gt;
			&lt;cexfunction name="ForwardForwardPhone" delim="=" isinteger="0" /&gt;
			&lt;cexfunction name="SegmentLocationFromFront" delim="/00:" isinteger="1" /&gt;
			&lt;cexfunction name="SegmentLocationFromBack" delim="/01:" isinteger="1" /&gt;
			&lt;cexfunction name="BackwardSyllableStress" delim="/02:" isinteger="1" /&gt;
			&lt;cexfunction name="SyllableStress" delim="/03:" isinteger="1" /&gt;
			&lt;cexfunction name="ForwardSyllableStress" delim="/04:" isinteger="1" /&gt;
			&lt;cexfunction name="BackwardWordPosTag" delim="/05:" isinteger="0" /&gt;
			&lt;cexfunction name="WordPosTag" delim="/06:" isinteger="0" /&gt;
			&lt;cexfunction name="ForwardWordPosTag" delim="/07:" isinteger="0" /&gt;
			&lt;cexfunction name="BackwardSyllableNumPhones" delim="/08:" isinteger="1" /&gt;
			&lt;cexfunction name="SyllableNumPhones" delim="/09:" isinteger="1" /&gt;
			&lt;cexfunction name="ForwardSyllableNumPhones" delim="/10:" isinteger="1" /&gt;
			&lt;cexfunction name="BackwardWordNumSyls" delim="/11:" isinteger="1" /&gt;
			&lt;cexfunction name="WordNumSyls" delim="/12:" isinteger="1" /&gt;
			&lt;cexfunction name="ForwardWordNumSyls" delim="/13:" isinteger="1" /&gt;
			&lt;cexfunction name="PhraseNumWords" delim="/14:" isinteger="1" /&gt;
			&lt;cexfunction name="PhraseTobiEndTone" delim="/17:" isinteger="0" /&gt;
		&lt;/cex&gt;
	&lt;/txpheader&gt;
	&lt;utt uttid="1" no_phrases="2"&gt;
		&lt;spt phraseid="1" no_wrds="2"&gt;
			&lt;ws col="0" /&gt;
			&lt;break type="4" time="0.011"&gt;
				&lt;tk pron="pau"&gt;
					&lt;syl val="pau"&gt;
						&lt;phon val="pau"&gt;^sil~sil-pau+hh=ah/00:0/01:0/02:0/03:0/04:0/05:PAU/06:PAU/07:NN/08:0/09:0/10:2/11:0/12:0/13:2/14:2/17:LL&lt;/phon&gt;
					&lt;/syl&gt;
				&lt;/tk&gt;
			&lt;/break&gt;
			&lt;tk norm="hello" lc="true" uc="true" pos="NN" posset="1" wordid="1" pron="hh ah0 l ow1" altprons="hh eh0 l ow1, hh ah0 l ow1" spron="hh+ah0|l+ow1|" nosyl="2"&gt;
				Hello
				&lt;ws /&gt;
				&lt;syl val="hh+ah0" stress="0" sylid="1" nophons="2"&gt;
					&lt;phon val="hh" type="onset" phonid="1"&gt;^sil~pau-hh+ah=l/00:0/01:1/02:0/03:0/04:1/05:PAU/06:NN/07:EX/08:0/09:2/10:2/11:0/12:2/13:1/14:2/17:LL&lt;/phon&gt;
					&lt;phon val="ah" type="nucleus" phonid="2"&gt;^pau~hh-ah+l=ow/00:1/01:0/02:0/03:0/04:1/05:PAU/06:NN/07:EX/08:0/09:2/10:2/11:0/12:2/13:1/14:2/17:LL&lt;/phon&gt;
				&lt;/syl&gt;
				&lt;syl val="l+ow1" stress="1" sylid="2" nophons="2"&gt;
					&lt;phon val="l" type="onset" phonid="1"&gt;^hh~ah-l+ow=dh/00:0/01:1/02:0/03:1/04:1/05:PAU/06:NN/07:EX/08:2/09:2/10:3/11:0/12:2/13:1/14:2/17:LL&lt;/phon&gt;
					&lt;phon val="ow" type="nucleus" phonid="2"&gt;^ah~l-ow+dh=eh/00:1/01:0/02:0/03:1/04:1/05:PAU/06:NN/07:EX/08:2/09:2/10:3/11:0/12:2/13:1/14:2/17:LL&lt;/phon&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
...
</pre><p>If we run the program with the switch altered to &ndash;cex-arch=kaldi the model names are altered replacing delimeters between all non phone contexts with whitespace.</p>
<pre class="fragment">...
&lt;phon val="pau"&gt;^0~0-0+hh=ah 0 0 0 0 0 PAU PAU NN 0 0 2 0 0 2 2 LL&lt;/phon&gt;
...
&lt;phon val="hh" type="onset" phonid="1"&gt;^0~0-hh+ah=l 0 1 0 0 1 PAU NN EX 0 2 2 0 2 1 2 LL&lt;/phon&gt;
... etc.
</pre><p>The &ndash;cex-arch switch causes the program to load different setup files from the tpdb (text processing database) in these examples either ../../idlak-data/en/ga/cex-hts.xml or ../../idlak-data/en/ga/cex-kaldi.xml</p>
<p>See voicebuilding documentation for more detail (idlakvoicebuild).</p>
<h1><a class="anchor" id="idlakcex_qarchi"></a>
Question Architecture</h1>
<p>The front end procesing and the context extraction associated with it can be used standalone within Kaldi Idlak in order to generate linguistic analysis or for other backend TTS systems.</p>
<p>The question architecture is part of the Idlak voice build system but is closely linked to the context extraction system. This is because, within parametric TTS systems questions are used to help take the very sparse full context models and group them into combined models. It is vital that the context extraction matches such question files. If they do not the voice training behavior becomes unspecified, often without being able to detect errors and mismatches, and producing very hard to detect output errors.</p>
<p>The Idlak Question Architecture is designed to:</p>
<ol type="1">
<li>Minimise the chance of mismatches between questions and contexts.</li>
<li>Produce warnings for unusual context extraction results (e.g. no variation, unusual values)</li>
<li>To make it easy to choose contexts and questions from a superset allowing experimentation and development of optimal sets.</li>
</ol>
<p>A question set based on the HTS question set distributed with the HTS DEMO is included in the system. Selecting a subset of these questions and contexts is a simple process, adding new questions and new context extraction is more complex requiring a careful march between cex configuration code, the question set, and C++ context extraction functions (see <a class="el" href="idlakcex.html#idlakcex_addcex">Adding Context Extraction Functions</a> and <a class="el" href="idlakcex.html#idlakcex_addqst">Adding Context Questions</a>).</p>
<p>The default question set used in voice building is ../../idlak-data/en/ga/qset-default.xml in order to allow cross development between HTKHTS and Kaldi Idlak names familiar to HTS users are used as well as Idlak context function names.</p>
<p>In HTK such questions are written as follows: </p><pre class="fragment">QS "LL-Stop" {^b~*,^d~*,^g~*,^k~*,^p~*,^t~*}
</pre><p> whereas in Kladi Idlak they would have the form </p><pre class="fragment">5 ? 7 9 15 20 27 31
</pre><p>In HTS, the delimeters identify the context, in Kaldi the index of the context is used. HTS question style names are used within Kaldi to help make warnings and error output easier to understand.</p>
<p>Below is an example of the XML specification of a question: </p><pre class="fragment">&lt;?xml version="1.0" ?&gt;
&lt;qset&gt;
 ...		
        &lt;feat htsname="C-Syl_Stress" name="SyllableStress"&gt;
                &lt;qs name="C-Syl_Stress==0"&gt;
                        0
                &lt;/qs&gt;
                &lt;qs name="C-Syl_Stress==1"&gt;
                        1
                &lt;/qs&gt;
        &lt;/feat&gt;
...
&lt;/qset&gt;
</pre><p>The questions qs are stored by the context they are tied with. The context is identified by an HTS name for convnenience and by the context extraction function name (as per the cex configuration file) WHICH MUST EXACTLY MATCH THE CONTEXT EXTRACTION FUNCTION WRITTEN IN C++. During voice building only questions matching the contexts which are selected for that voice build are used. The valid values for a yes reponse are space delimited and must match the context type (string or integer).</p>
<p>The process for encoding questions in Kaldi format in the voice building system is as follows:</p>
<ol type="1">
<li>Create a lookup table for all string contexts which map an integer onto the string value. 0 is reserved for a NULL value (defined in the cex configuration which is typically '0'.</li>
<li>The frequency of all features values and appropriate lookup tables are stored by the context index based on the header output from cex. For exampl cex000_freq.txt and cex000_lkp.txt relate to the function BackwardBackwardPhone.</li>
<li>The index of the context is incremented by 5 to deal with the automatically generated questions based on a quinphone model.</li>
<li>In kaldi built trees the context -1 is the state number of the model within the phone. This differes from HTK where a seperate tree is built for each state</li>
</ol>
<h1><a class="anchor" id="idlakcex_addcex"></a>
Adding Context Extraction Functions</h1>
<p>IN PREPARATION</p>
<h1><a class="anchor" id="idlakcex_addqst"></a>
Adding Context Questions</h1>
<p>IN PREPARATION </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
