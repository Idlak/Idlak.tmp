<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Kaldi: The Idlak text processing system</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" /> 
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
 <td id="projectlogo"><a href="http://kaldi-asr.org/"><img alt="Logo" src="KaldiTextAndLogoSmall.png"/ style="padding: 3px 5px 1px 5px"></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname" style="display:none">Kaldi
   </div>
  </td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief" style="display:none"></div>
    </td>
   <!--END PROJECT_BRIEF-->
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('idlaktxp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Idlak text processing system </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="idlaktxp_intro"></a>
Introduction</h1>
<p>In order to generate speech synthesis we start with text input. This input is typically unnormalised text. For example it may contain tokens such as "Â£10", "12/10/98", "IBM" which need to be expanded into words that we can look up in a dictionary. Furthermore, there may be further issues with this look up process, the word may not me in the lexicon, it may have several pronunciations depending on context. Finally the system needs to decide how to phrase and structure the sounds it will produce. For example how long a pause should be inserted between sentences, what sort of syllabification and word boundaries should be used.</p>
<p>The Idlak text processing front end (idlaktxp) looks after this process, normalising tokens into words, assigning part of speech tags to help disambiguate word pronunciations, adding pauses and phrase structure, assigning pronunciation to words and adding syllable structure.</p>
<p>The system comprises of a set of modules. Each module takes a well formed XML input and outputs a well formed XML output. A set of XML files which contain data that controls the process can be read in by each module and used to control processing. The final output is a marked up XML document which can be used as an input to the Idlak feature extraction system, or could format the basis of a 3rd part feature extraction system.</p>
<h1><a class="anchor" id="idlaktxp_archi"></a>
Architecture</h1>
<p>The system is comprised of a set of modules. Each module takes an XML input, may contain some data objects which are built from XML input data, and outputs an XML marked up version of the input.</p>
<p>Three 3rd party libraries are used to help with the text processing. PCRE compiled with unicode support, which is used to handle regular expression matching controlled through the text normalisation object (nrules). Pujixml which is used to access and iterate across XML input generally using xpath, expat which is used to read in XML voice data used by data objects (voice data). Expat is used in addition to pujixml because voice data files can be large (e.g. 200k lines in an input lexicon), and thus an event driven XML parser is more efficient for loading this data. In addition the structure of voice data is normally quite simple and an event driven parser is reasonable easy to use. Both pcre and expat are wrapped into a C++ object within idlaktxp.</p>
<p>A set of utilities are also used across the system (at present a very thinned down set of utf8 functions).</p>
<p>Currently data objects are loaded more than once if used by more than one module. This means it is easy to write a command line application which carries out only one module's function, although currently only a single monolithic system is available (in idlakxpbin). See below for a schematic of the system.</p>
<div class="image">
<img src="idlaktxp.png" alt="idlaktxp.png"/>
</div>
<h1><a class="anchor" id="idlaktxp_voice_data"></a>
Voice Data</h1>
<p>Example XML files are available for English General American accent. These are currently located in idlak-data. More files for more languages and accents can be added in future. Although some data is general across speakers the data is currently held by speaker id &lt;corpus&gt;-&lt;spkid&gt; where spkid is a three letter lower case ascii name. The first test voice will be arctic bdl.</p>
<p>Some of the voice data is hand created, such as the lexicon, others are automatically created using machine learning algorithms, such as CART based lts based on wagon).</p>
<p>Scripts to create data for new voices will be released at a future point.</p>
<h1><a class="anchor" id="idlaktxp_XML_tagset"></a>
XML tagset</h1>
<p>The modules have expectations for the tags used to markup input text. These tags are kept short for readability but this means they could clash with XML marked up input.</p>
<p>The core tags are as follows:</p>
<ul>
<li><b>fileid:</b> This can be used to break large texts into proposed output output files with the stem set based on the attribute id. This tag plays an important role in voice building by allowing input audio data to be matched up with normalisation output.</li>
<li><b>utt:</b> This is a series of spurts (see below) and equates to a sentence.</li>
<li><b>spt:</b> This is a spurt of speech.This is speech bounded by silences, and equates to a phrase.</li>
<li><b>ws:</b> Whitespace. Characters which have been processed as whitespace such as spaces, tabs, line breaks.</li>
<li><b>tk:</b> Tokens. The input text is split up into tokens. Often a token is a word but it can also be a series of symbols. For languages such as Mandarin a token can be part of a word. The pronunciation of the token is available as plain phones (pron), with syllable structure (spron) and also as sub tags (syl, phon). altpron atribute lists all possible prons for that word. if attribute lts = true then pron was generated using letter to sound rules.</li>
<li><b>break:</b> This tag represents a phrase break an has both a strength and a time associates with it. Often a break will be generated from punctuation.</li>
<li><b>syl:</b> This tag represents a syllable within a pronounced token.</li>
<li><b>phon:</b> This tag represents a sound unit in language.</li>
</ul>
<p>Break tags can be manually added to the input text and override the effect of punctuation. A spurt (spt) has by definition a break at its beginning and its end.</p>
<p>In addition other markup will effect the processing of the text and more importantly be retained to potentially control synthesis in later modules. Within idlaktxp the tag <b>lex</b> can allow the manual override of word pronunciation.</p>
<p>Below is an example of some text and the pretty printed resulting XML from idlaktxp.</p>
<pre class="fragment">&lt;parent&gt;
Hello there, 1 2 3.
&lt;/parent&gt;
</pre> <pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;parent&gt;
	&lt;utt uttid="1" no_phrases="2"&gt;
		&lt;spt phraseid="1" no_wrds="2"&gt;
			&lt;ws col="0"&gt;
&lt;/ws&gt;
			&lt;break type="4" time="0.011" /&gt;
			&lt;tk norm="hello" lc="true" uc="true" pos="NN" posset="1" wordid="1" pron="hh ah0 l ow1" spron="hh+ah0|l+ow1|" nosyl="2"&gt;
				Hello
				&lt;ws&gt; &lt;/ws&gt;
				&lt;syl val="hh+ah0" stress="0" sylid="1" nophons="2"&gt;
					&lt;phon val="hh" type="onset" phonid="1" /&gt;
					&lt;phon val="ah" type="nucleus" phonid="2" /&gt;
				&lt;/syl&gt;
				&lt;syl val="l+ow1" stress="1" sylid="2" nophons="2"&gt;
					&lt;phon val="l" type="onset" phonid="1" /&gt;
					&lt;phon val="ow" type="nucleus" phonid="2" /&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
			&lt;tk norm="there" pstpunc="," lc="true" pos="EX" posset="3" wordid="2" pron="dh eh1 r" spron="dh+eh1+r|" nosyl="1"&gt;
				there,
				&lt;ws&gt; &lt;/ws&gt;
				&lt;syl val="dh+eh1+r" stress="1" sylid="1" nophons="3"&gt;
					&lt;phon val="dh" type="onset" phonid="1" /&gt;
					&lt;phon val="eh" type="nucleus" phonid="2" /&gt;
					&lt;phon val="r" type="coda" phonid="3" /&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
			&lt;break type="3" time="0.1" /&gt;
		&lt;/spt&gt;
		&lt;spt phraseid="2" no_wrds="3"&gt;
			&lt;break type="3" time="0.1" /&gt;
			&lt;tk norm="1" symbols="true" pos="NN" posset="1" wordid="1" pron="w ah1 n" spron="w+ah1+n|" nosyl="1"&gt;
				1
				&lt;ws&gt; &lt;/ws&gt;
				&lt;syl val="w+ah1+n" stress="1" sylid="1" nophons="3"&gt;
					&lt;phon val="w" type="onset" phonid="1" /&gt;
					&lt;phon val="ah" type="nucleus" phonid="2" /&gt;
					&lt;phon val="n" type="coda" phonid="3" /&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
			&lt;tk norm="2" symbols="true" pos="NN" posset="1" wordid="2" pron="t uw1" spron="t+uw1|" nosyl="1"&gt;
				2
				&lt;ws&gt; &lt;/ws&gt;
				&lt;syl val="t+uw1" stress="1" sylid="1" nophons="2"&gt;
					&lt;phon val="t" type="onset" phonid="1" /&gt;
					&lt;phon val="uw" type="nucleus" phonid="2" /&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
			&lt;tk norm="3" pstpunc="." symbols="true" pos="NN" posset="1" wordid="3" pron="th r iy1" spron="th_r+iy1|" nosyl="1"&gt;
				3.
				&lt;ws col="20"&gt;
&lt;/ws&gt;
				&lt;syl val="th_r+iy1" stress="1" sylid="1" nophons="3"&gt;
					&lt;phon val="th" type="onset" phonid="1" /&gt;
					&lt;phon val="r" type="onset" phonid="2" /&gt;
					&lt;phon val="iy" type="nucleus" phonid="3" /&gt;
				&lt;/syl&gt;
			&lt;/tk&gt;
			&lt;break type="4" time="0.4" /&gt;
		&lt;/spt&gt;
	&lt;/utt&gt;
	&lt;utt uttid="2" /&gt;
&lt;/parent&gt;</pre><h1><a class="anchor" id="idlaktxp_description_modules"></a>
Description of Modules</h1>
<h2><a class="anchor" id="idlaktxp_token"></a>
Tokenisation</h2>
<p>Tokenisation is the basis for all following text processing. For English this is carried out by splitting text by whitespace, and by regarding some symbols as individual tokens (such as '\'). The choice of what symbols to split on is optional but once decided it will strongly affect the normalisation rules. Therefore it is strongly recommended to choose a tokenisation that produces the 'best' normalisation without normalisation rules and to avoid changing it.</p>
<p>Tokenisation also performs some default normalisation, such as replacing foreign characters with characters valid for the languages lexicon and downcasing characters. The old token is retained as text in the tk tag the normalised version added as an attribute.</p>
<p>The processing also adds attributes to record the case/symbol characteristics of the token.</p>
<p>Valid punctuation symbols are stripped from the tokens and added as pre and post (pst) punctuation attributes as appropriate. An attempt is made to disambiguate apostrophes from single quotes.</p>
<p>White space is also tokenised and the column location of a line break is recorded to deal with issues such as soft hyphenation.</p>
<h2><a class="anchor" id="idlaktxp_norm"></a>
Normalisation</h2>
<p>This module is still under construction. It is possible to fully test idlak with pre-normalised text so the details of normalisation have been left until after a full end to end prototype is in place. However the architecture of the normalisation has been designed. We briefly describe this intended design here.</p>
<p>The first thing this module does its to replace abbreviations. Abbreviations are very greedy catch alls that can be used for elements which have no ambiguity. For example these can't be used to replace 'Dr' with Doctor as this can be confused with 'Dr' as Drive. However it is the easiest user based normalisation to produce and for many users, although an abbreviation may be ambiguous over many texts, may not be for a specific user's text.</p>
<p>Abbreviations can have a context and can add XML values. The match process is very simple and requires case matching. i.e. IBM -&gt; i b m, :-) -&gt; smiley.</p>
<p>Normalisation then applies a group of rules in sequential order. Each rule within the group is greedy in that if it fires the group completes. In effect:</p>
<p>Group1(rule1 | rule2 | rule3 etc) &amp; Group2(rule1 | rule2 | rule3 etc) &amp; etc</p>
<p>Thus a group will typically represent a series of mutually exclusive actions on a token such as 'date formats'. Furthermore, because a group will change tokens, actions that require the most context, and are best defined, need to be before more general action.</p>
<p>Rules have a match and a replace section. The matches need to be true to fire the rule, and will record elements that have been matched. If the match is successful the replace will reformat the token and potentially other tokens around the target token.</p>
<p>Below is an example of a rules to detect tokens like '7th Flr.' in US addresses.</p>
<pre class="fragment">  &lt;rule name="american_address_misc_rev" type="postaddress1"&gt;
    &lt;comment&gt;
      Cover cases the '7th', as in '7th Flr.'.
    &lt;/comment&gt;
    &lt;match&gt;
      &lt;com name="R:snumber_er_m" in="t-00"/&gt;
      &lt;com name="R:american_address_misc" in="t+01"/&gt;
    &lt;/match&gt;
    &lt;replace&gt;
      &lt;com name="H:none" in="[00]$00" out="t-00:$XX"/&gt;
      &lt;com name="H:number" in="[00]$02" out="t-00:$XX" case="ordinal"/&gt;
      &lt;com name="H:number" in="[00]$03" out="t-00:$XX" case="ordinal"/&gt;
      &lt;com name="H:number" in="[00]$04" out="t-00:$XX" case="ordinal"/&gt;
      &lt;com name="H:number" in="[00]$05" out="t-00:$XX" case="ordinal"/&gt;
      &lt;com name="L:address_abbrev_2nd_unit" in="[01]" out="t+01:$XX" attribute="@break type=0 time=0"/&gt;
    &lt;/replace&gt;
  &lt;/rule&gt;
</pre><p>The match is made of a series of commands (com tags) which apply a regular expression to a token indexed from the current token e.g. 't-00' is the current token, t+01 is the next token, t-01 is the previous token.</p>
<p>In this rule the token (t-00) is first matched as an ordinal number "R:snumber_er_m", the following token is then matched against a set of US abbreviations "R:american_address_misc". If these both match, the ordinal number regex returns four match groups (although only one is ever filled). If none match it appends nothing, else it will append the matching group converted into words (i.e. seventh), using a hard coded number to words rule "H:number". Finally it will transform the following token into an unabbreviated form (i.e. floor).</p>
<p>Rules can interact by setting XML values in the token. However care is required to avoid unintended consequences from such interactions. Every added rule should have an example sentence in a regression test that is processed by the rule.</p>
<h2><a class="anchor" id="idlaktxp_pause_insertion"></a>
Pause Insertion</h2>
<p>Once normalisation and part of speech has been determined punctuation can then be used to decide on pause insertion. Each punctuation character is connected with. Breaks override each other in magnitude so a break 4 in the same position as a break 2 will result in a break 4. Pre marked up breaks will override any break caused by punctuation.</p>
<h2><a class="anchor" id="idlaktxp_pos"></a>
Part of Speech Tagging</h2>
<p>Part of speech tagging for synthesis has a different function than from more general language processing. In general part of speech information is only required if it can help determine pronunciation. For this reason the POS tagger incorporated into idlak is very simple and by no means as accurate as many state of the art taggers.</p>
<p>It relies on a four level process:</p>
<ol type="1">
<li>Give every word the most likely tag name.</li>
<li>Apply a series of regular expressions that can change this tag to another more likely tag name based on prefixes and suffixes.</li>
<li>Look up common words that will alter the tag to the most likely tag for this word.</li>
<li>look up the previous tag and this word that will alter the tag to the most likely tag for this word.</li>
</ol>
<p>The system is very fast and easy to train from tagged data. A dynamic programming algorithm would, however, be superior. In addition the current system ignores pre-normalised information, e.g. '12' is clearly a cardinal number, 'Top Gun' is probably a name because of capitalisation.</p>
<p>In addition the system is not properly taking pauses into consideration as indications of punctuation.</p>
<h2><a class="anchor" id="idlaktxp_phrase"></a>
Phrasing</h2>
<p>This module restructures the XML by putting ws and tk tokens in spt tags. This has an effect on markup already present in the text. Currently a tag is copied if it crosses an spt boundary. fileid tags are maintained at a top level and force utterance breaks at their beginning and end.</p>
<p>Although not implemented as yet, it is possible to guess breaks in long unpunctuated series of tokens using part of speech.</p>
<h2><a class="anchor" id="idlaktxp_pron"></a>
Pronunciation</h2>
<p>idlaktxp is a word based system. By the time we get to the pronunciation module we should have a series of word tokens together with some symbols. The pronunciation system has the following means of converting these words into a series of phones representing the pronunciation of each word or symbol.</p>
<ol type="1">
<li>The pronunciation of a word can be over ridden by specifying it using a <b>lex</b> tag and a <b>pron</b> attribute with a space separated series of valid phone symbols. Syllabic liaison can also be specified here (<dl class="section see"><dt>See also</dt><dd>idlaktxp_syl)</dd></dl>
</li>
<li>If the word contains non lexical symbols, read them out character by character. Or if the attribute</li>
<li>Look the word up in a series of lexicons. In the prototype there is only one lexicon, but in a final system we can imagine a cascade of lexicons. A user lexicon for unusual user specific words, a system lexicon for standard lookup, and potentially alternative lexicons for technical terms or alternative languages to support a bilingual system. A word may have more than one pronunciation so the lexicon lookup will also support multiple entries. In a final system the entry type could be chosen based on context and POS. Alternatively it could be overridden using markup in the input.</li>
<li>If the word is not in the lexicon apply letter to sound rules to the letters to produce a pronunciation. The LTS system is built offline using wagon from University of Edinburgh speech_tools together with the lexicon.</li>
</ol>
<p>In future releases modules to deal with changes in pronunciation caused by phrase structure (such as whether to choose full or reduced forms of a word) can be added. Also an archiphone rule system which allows phones to be elided, inserted and altered based on word context will be required.</p>
<h2><a class="anchor" id="idlaktxp_syll"></a>
Syllabification</h2>
<p>Maximal onset syllabification is used to syllabify input words. This algorithm works by finding nuclei, potentially multiple phones with specific stress patterns which are the nucleus of syllables. A set of valid onsets are then applied to the phones before the nucleus to decide where the syllable boundary should be. Material from a previous word can be liaised to a subsequent word if the last phone is followed by a '+' symbol.</p>
<p>In future release syllabification can be over ridden by the lexicon. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
